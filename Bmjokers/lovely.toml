[manifest]
version = "1.0.4c"
dump_lua = true
priority = 0

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''if self.ability and self.ability.perma_debuff then self.debuff = true end'''
position = "after"
payload = '''
    if self.ability.name == 'Supergodcard' then
        local sum = 0
        for i = 1, #G.consumeables.cards do
            sum = sum + G.consumeables.cards[i].sell_cost 
        end
        self.ability.extra.suml = sum
    end

    if self.ability.name == 'Smartcowboy' then
        local smartcowboy_mult = math.floor((G.GAME.dollars + (G.GAME.dollar_buffer or 0))/self.ability.extra.perdollar)
        self.ability.extra.x_mult = 1 + self.ability.extra.perxmult * math.abs(smartcowboy_mult)
    end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''if self.ability.name == 'Blueprint' or self.ability.name == 'Brainstorm' then'''
position = "before"
payload = '''
    if self.ability.name == 'Microchip' then
        local left_joker = nil
        local right_joker = nil
        for i = 1, #G.jokers.cards do
            if G.jokers.cards[i] == self then
                local index = i - 1
                local index1 = i + 1
                local index2 = index1
                local index3 = 1
                local index4 = index3
                while index > 0 and G.jokers.cards[index].ability and G.jokers.cards[index].ability.name == 'Microchip' and not G.jokers.cards[index].debuff do
                    index = index - 1
                end
                if index > 0 and G.jokers.cards[index].ability and G.jokers.cards[index].ability.name == 'Blueprint' and not G.jokers.cards[index].debuff then
                    while index1 <= #G.jokers.cards and G.jokers.cards[index1].ability and (G.jokers.cards[index1].ability.name == 'Microchip' or G.jokers.cards[index1].ability.name == 'Blueprint') and not G.jokers.cards[index1].debuff do
                        index1 = index1 + 1
                    end
                    if index1 <= #G.jokers.cards and G.jokers.cards[index1].ability and G.jokers.cards[index1].ability.name == 'Brainstorm' and not G.jokers.cards[index1].debuff then
                        while G.jokers.cards[index3].ability and (G.jokers.cards[index3].ability.name == 'Microchip' or G.jokers.cards[index3].ability.name == 'Blueprint') and not G.jokers.cards[index3].debuff do
                            index3 = index3 + 1
                        end
                        if G.jokers.cards[index3].ability and G.jokers.cards[index3].ability.name ~= 'Brainstorm' then
                            left_joker = G.jokers.cards[index3]
                        end
                    elseif index1 <= #G.jokers.cards and G.jokers.cards[index1].ability and G.jokers.cards[index1].ability.name ~= 'Brainstorm' then
                        left_joker = G.jokers.cards[index1]
                    end
                elseif index > 0 and G.jokers.cards[index].ability and G.jokers.cards[index].ability.name == 'Brainstorm' and not G.jokers.cards[index].debuff then
                    while G.jokers.cards[index3].ability and (G.jokers.cards[index3].ability.name == 'Microchip' or G.jokers.cards[index3].ability.name == 'Blueprint') and not G.jokers.cards[index3].debuff do
                        index3 = index3 + 1
                    end
                    if G.jokers.cards[index3].ability and G.jokers.cards[index3].ability.name ~= 'Brainstorm' then
                        left_joker = G.jokers.cards[index3]
                    end
                elseif index > 0 then
                    left_joker = G.jokers.cards[index]
                end
                while index2 <= #G.jokers.cards and G.jokers.cards[index2].ability and (G.jokers.cards[index2].ability.name == 'Microchip' or G.jokers.cards[index2].ability.name == 'Blueprint') and not G.jokers.cards[index2].debuff do
                    index2 = index2 + 1
                end
                if index2 <= #G.jokers.cards and G.jokers.cards[index2].ability and G.jokers.cards[index2].ability.name == 'Brainstorm' and not G.jokers.cards[index2].debuff then
                    while G.jokers.cards[index4].ability and (G.jokers.cards[index4].ability.name == 'Microchip' or G.jokers.cards[index4].ability.name == 'Blueprint') and not G.jokers.cards[index4].debuff do
                        index4 = index4 + 1
                    end
                    if G.jokers.cards[index4].ability and G.jokers.cards[index4].ability.name ~= 'Brainstorm' then
                        right_joker = G.jokers.cards[index4]
                    end
                elseif index2 <= #G.jokers.cards then
                    right_joker = G.jokers.cards[index2]
                end
            end
        end
        if left_joker and left_joker ~= self and left_joker.config.center.blueprint_compat then
            self.ability.leftblueprint_compat = 'compatible'
        else
            self.ability.leftblueprint_compat = 'incompatible'
        end
        if right_joker and right_joker ~= self and right_joker.config.center.blueprint_compat then
            self.ability.rightblueprint_compat = 'compatible'
        else
            self.ability.rightblueprint_compat = 'incompatible'
        end
    end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''if self.ability.name == "Blueprint" then'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''if context.open_booster then'''
position = "before"
payload = '''
]]
            local other_joker = nil
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == self then other_joker = G.jokers.cards[i+1] end
            end
            if other_joker and other_joker ~= self then
                context.blueprint = (context.blueprint and (context.blueprint + 1)) or 1
                context.blueprint_card = context.blueprint_card or self
                if context.blueprint > #G.jokers.cards + 1 then
                    return
                end
                local other_joker_ret, trig = other_joker:calculate_joker(context)
                if other_joker_ret then 
                    other_joker_ret.card = context.blueprint_card or self
                    other_joker_ret.colour = G.C.BLUE
                end
            end
        end
        if self.ability.name == "Brainstorm" then
            local other_joker = G.jokers.cards[1]
            if other_joker and other_joker ~= self then
                context.blueprint = (context.blueprint and (context.blueprint + 1)) or 1
                context.blueprint_card = context.blueprint_card or self
                if context.blueprint > #G.jokers.cards + 1 then
                    return
                end
                local other_joker_ret, trig = other_joker:calculate_joker(context)
                if other_joker_ret then 
                    other_joker_ret.card = context.blueprint_card or self
                    other_joker_ret.colour = G.C.RED
                end
            end
        end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "set = center.set,"
position = "after"
payload = '''
retriggers = self.ability and self.ability.retriggers or 0,
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''local hand_text_set = false'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''mult, hand_chips, modded = G.GAME.blind:modify_hand(G.play.cards, poker_hands, text, mult, hand_chips)'''
position = "before"
payload = '''
]]
        for i=1, #G.jokers.cards do
            --calculate the joker effects
            local retri = 1
            local m = 1
            while m <= retri do
                if m == 1 then
                    if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                        retri = retri + G.jokers.cards[i].ability.retriggers
                    end
                end
            local effects = eval_card(G.jokers.cards[i], {cardarea = G.jokers, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, before = true, callback = function(card, ret) effects = {jokers = ret}
            if effects.jokers then
                if m ~= 1 then
                    card_eval_status_text(G.jokers.cards[i], 'jokers', nil, nil, nil, {message = localize('s_energy'), colour = G.C.BLACK})
                end
                card_eval_status_text(card, 'jokers', nil, percent, nil, effects.jokers)
                percent = percent + percent_delta
                if effects.jokers.level_up then
                    level_up_hand(card, text)
                end
            end 
        end})
        m = m + 1
        end
        end

        mult = mod_mult(G.GAME.hands[text].mult)
        hand_chips = mod_chips(G.GAME.hands[text].chips)

        local modded = false         
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''local eval = eval_card(scoring_hand[i], {repetition_only = true,cardarea = G.play, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, repetition = true})'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''local effects = {eval_card(scoring_hand[i], {cardarea = G.play, full_hand = G.play.cards, scoring_hand = scoring_hand, poker_hand = text})}'''
position = "before"
payload = '''
]]
                if next(eval) then 
                    for h = 1, eval.seals.repetitions do
                        reps[#reps+1] = eval
                    end
                end
                --From jokers
                for j=1, #G.jokers.cards do
                    --calculate the joker effects
                    local retri = 1
                    local m = 1
                    while m <= retri do
                        if m == 1 then
                            if G.jokers.cards[j].ability.retriggers and G.jokers.cards[j].ability.retriggers > 0 then
                                retri = retri + G.jokers.cards[j].ability.retriggers
                            end
                        end
                        local eval = eval_card(G.jokers.cards[j], {cardarea = G.play, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, other_card = scoring_hand[i], repetition = true, callback = function(card, ret) eval = {jokers = ret}
                            if next(eval) and eval.jokers then
                                for h = 1, eval.jokers.repetitions do
                                    if m ~= 1 and h == 1 then
                                        local _eval = shallow_copy(eval)
                                        _eval.from_retriggers = {message = localize('s_energy'), colour = G.C.BLACK, card = G.jokers.cards[j]}
                                        reps[#reps+1] = _eval
                                    else
                                        reps[#reps+1] = eval
                                    end
                                end
                            end end})
                    m = m + 1
                    end
                end
                for j=1,#reps do
                    percent = percent + percent_delta
                    if reps[j] ~= 1 and reps[j].from_retriggers then
                        card_eval_status_text(reps[j].from_retriggers.card, 'jokers', nil, nil, nil, reps[j].from_retriggers)
                    end
                    if reps[j] ~= 1 then
                        card_eval_status_text((reps[j].jokers or reps[j].seals).card, 'jokers', nil, nil, nil, (reps[j].jokers or reps[j].seals))
                    end
                    
                    --calculate the hand effects
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''local effects = {eval_card(scoring_hand[i], {cardarea = G.play, full_hand = G.play.cards, scoring_hand = scoring_hand, poker_hand = text})}'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''scoring_hand[i].lucky_trigger = nil'''
position = "before"
payload = '''
]]
                    for k=1, #G.jokers.cards do
                        --calculate the joker individual card effects
                        local retri = 1
                        local m = 1
                        while m <= retri do
                            if m == 1 then
                                if G.jokers.cards[k].ability.retriggers and G.jokers.cards[k].ability.retriggers > 0 then
                                    retri = retri + G.jokers.cards[k].ability.retriggers
                                end
                            end
                        local eval = G.jokers.cards[k]:calculate_joker({cardarea = G.play, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, other_card = scoring_hand[i], individual = true, callback = function(card, eval, retrigger)
                        if eval then 
                            table.insert(effects, eval)
effects[#effects].from_retrigger = retrigger
                            if m ~= 1 then
                                if G.jokers.cards[k].ability.retriggers and G.jokers.cards[k].ability.retriggers > 0 then
                                    effects[#effects].from_retriggers = {message = localize('s_energy'), colour = G.C.BLACK, card = G.jokers.cards[k]}
                                end
                            end
end end, no_retrigger_anim = true})
                        m = m + 1
                        end
                    end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''--If chips added, do chip add event and add the chips to the total'''
position = "after"
payload = '''
                    if effects[ii].from_retriggers then
                        card_eval_status_text(effects[ii].from_retriggers.card, 'jokers', nil, nil, nil, effects[ii].from_retriggers)
                    end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''if mod_percent then percent = percent + percent_delta end'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''local eval = eval_card(G.hand.cards[i], {repetition_only = true,cardarea = G.hand, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, repetition = true, card_effects = effects})'''
position = "before"
payload = '''
]]
                mod_percent = false

                --Check for hand doubling
                local reps = {1}
                local j = 1
                while j <= #reps do
                    if reps[j] ~= 1 and reps[j].from_retriggers then
                        card_eval_status_text(reps[j].from_retriggers.card, 'jokers', nil, nil, nil, reps[j].from_retriggers)
                    end
                    if reps[j] ~= 1 then
                        card_eval_status_text((reps[j].jokers or reps[j].seals).card, 'jokers', nil, nil, nil, (reps[j].jokers or reps[j].seals))
                        percent = percent + percent_delta
                    end

                    --calculate the hand effects
                    local effects = {eval_card(G.hand.cards[i], {cardarea = G.hand, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands})}
                    for k=1, #G.jokers.cards do
                        --calculate the joker individual card effects
                        local retri = 1
                        local m = 1
                        while m <= retri do
                            if m == 1 then
                                if G.jokers.cards[k].ability.retriggers and G.jokers.cards[k].ability.retriggers > 0 then
                                    retri = retri + G.jokers.cards[k].ability.retriggers
                                end
                            end
                        local eval = G.jokers.cards[k]:calculate_joker({cardarea = G.hand, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, other_card = G.hand.cards[i], individual = true, callback = function(card, eval, retrigger)
                        if eval then 
                            mod_percent = true
                            table.insert(effects, eval)
effects[#effects].from_retrigger = retrigger
                            if m ~= 1 then
                                if G.jokers.cards[k].ability.retriggers and G.jokers.cards[k].ability.retriggers > 0 then
                                    effects[#effects].from_retriggers = {message = localize('s_energy'), colour = G.C.BLACK, card = G.jokers.cards[k]}
                                end
                            end
end end, no_retrigger_anim = true})
                        m = m + 1
                        end
                    end

                    if reps[j] == 1 then 
                        --Check for hand doubling

                        --From Red seal
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''local eval = eval_card(G.hand.cards[i], {repetition_only = true,cardarea = G.hand, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, repetition = true, card_effects = effects})'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''--If hold mult added, do hold mult add event and add the mult to the total'''
position = "before"
payload = '''
]]
                        if next(eval) and (next(effects[1]) or #effects > 1) then 
                            for h  = 1, eval.seals.repetitions do
                                reps[#reps+1] = eval
                            end
                        end

                        --From Joker
                        for j=1, #G.jokers.cards do
                            --calculate the joker effects
                            local retri = 1
                            local m = 1
                            while m <= retri do
                                if m == 1 then
                                    if G.jokers.cards[j].ability.retriggers and G.jokers.cards[j].ability.retriggers > 0 then
                                        retri = retri + G.jokers.cards[j].ability.retriggers
                                    end
                                end
                            local eval = eval_card(G.jokers.cards[j], {cardarea = G.hand, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, other_card = G.hand.cards[i], repetition = true, card_effects = effects, callback = function(card, ret) eval = {jokers = ret}
                            if next(eval) then
                                for h = 1, eval.jokers.repetitions do
                                    if m ~= 1 and h == 1 then
                                        local _eval = shallow_copy(eval)                                       
                                        _eval.from_retriggers = {message = localize('s_energy'), colour = G.C.BLACK, card = G.jokers.cards[j]}
                                        reps[#reps+1] = _eval
                                    else
                                        reps[#reps+1] = eval
                                    end
                                end
                            end end})
                            m = m + 1
                            end
                        end
                    end
    
                    for ii = 1, #effects do
                        if effects[ii].from_retriggers then
                            card_eval_status_text(effects[ii].from_retriggers.card, 'jokers', nil, nil, nil, effects[ii].from_retriggers)
                        end
                        --if this effect came from a joker
                        if effects[ii].card then
                            mod_percent = true
                            G.E_MANAGER:add_event(Event({
                                trigger = 'immediate',
                                func = (function() effects[ii].card:juice_up(0.7);return true end)
                            }))
                        end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''mult_mod =  edition_effects.jokers.mult_mod,'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''--Joker on Joker effects'''
position = "before"
payload = '''
]]
                        colour = G.C.DARK_EDITION,
                        edition = true})
                end
                percent = percent+percent_delta
            end
            
            --calculate the joker effects
            local retri = 1
            local m = 1
            while m <= retri do
                if m == 1 then
                    if _card.ability.retriggers and _card.ability.retriggers > 0 then
                        retri = retri + _card.ability.retriggers
                    end
                end
            local effects = eval_card(_card, {cardarea = G.jokers, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, joker_main = true, callback = function(_card, ret) effects = {jokers = ret}
            
            --Any Joker effects
            if effects.jokers then 
                if m ~= 1 then
                    card_eval_status_text(_card, 'jokers', nil, nil, nil, {message = localize('s_energy'), colour = G.C.BLACK, card = _card})
                end
                local extras = {mult = false, hand_chips = false}
                if effects.jokers.mult_mod then mult = mod_mult(mult + effects.jokers.mult_mod);extras.mult = true end
                if effects.jokers.chip_mod then hand_chips = mod_chips(hand_chips + effects.jokers.chip_mod);extras.hand_chips = true end
                if effects.jokers.Xmult_mod then mult = mod_mult(mult*effects.jokers.Xmult_mod);extras.mult = true  end
                update_hand_text({delay = 0}, {chips = extras.hand_chips and hand_chips, mult = extras.mult and mult})
                card_eval_status_text(_card, 'jokers', nil, percent, nil, effects.jokers)
                percent = percent+percent_delta
            end end})
            m = m + 1
            end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''--Joker on Joker effects'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''x_mult_mod =  edition_effects.jokers.x_mult_mod,'''
position = "before"
payload = '''
]]
            for _, v in ipairs(G.jokers.cards) do
                local retri = 1
                local m = 1
                while m <= retri do
                    if m == 1 then
                        if v.ability.retriggers and v.ability.retriggers > 0 then
                            retri = retri + v.ability.retriggers
                        end
                    end
                local effect = v:calculate_joker({full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, other_joker = _card, callback = function(v, effect)
                if effect then
                    if m ~= 1 then
                       card_eval_status_text(_card, 'jokers', nil, nil, nil, {message = localize('s_energy'), colour = G.C.BLACK})
                    end
                    local extras = {mult = false, hand_chips = false}
                    if effect.mult_mod then mult = mod_mult(mult + effect.mult_mod);extras.mult = true end
                    if effect.chip_mod then hand_chips = mod_chips(hand_chips + effect.chip_mod);extras.hand_chips = true end
                    if effect.Xmult_mod then mult = mod_mult(mult*effect.Xmult_mod);extras.mult = true  end
                    if extras.mult or extras.hand_chips then update_hand_text({delay = 0}, {chips = extras.hand_chips and hand_chips, mult = extras.mult and mult}) end
                    if extras.mult or extras.hand_chips then card_eval_status_text(_card, 'jokers', nil, percent, nil, effect) end
                    percent = percent+percent_delta
                end end})
                m = m + 1
                end
                end if edition_effects.jokers then
                if edition_effects.jokers.x_mult_mod then
                    mult = mod_mult(mult*edition_effects.jokers.x_mult_mod)
                    update_hand_text({delay = 0}, {mult = mult})
                    card_eval_status_text(_card, 'jokers', nil, percent, nil, {
                        message = localize{type='variable',key='a_xmult',vars={edition_effects.jokers.x_mult_mod}},
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''--Joker on Joker effects'''
position = "at"
payload = '''
            ---Joker on Joker effects
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''highlight_card(scoring_hand[i],(i-0.999)/(#scoring_hand-0.998),'down')'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''if scoring_hand[i].ability.name == 'Glass Card' and not scoring_hand[i].debuff and pseudorandom('glass') < G.GAME.probabilities.normal/scoring_hand[i].ability.extra then'''
position = "before"
payload = '''
]]
            for j = 1, #G.jokers.cards do
                local retri = 1
                local m = 1
                while m <= retri do
                    if m == 1 then
                        if G.jokers.cards[j].ability.retriggers and G.jokers.cards[j].ability.retriggers > 0 then
                            retri = retri + G.jokers.cards[j].ability.retriggers
                        end
                    end
                destroyed = G.jokers.cards[j]:calculate_joker({destroying_card = scoring_hand[i], full_hand = G.play.cards, callback = function(card, ret) if ret then
                    if m ~= 1 then
                       card_eval_status_text(G.jokers.cards[j], 'jokers', nil, nil, nil, {message = localize('s_energy'), colour = G.C.BLACK})
                    end
                destroyed=true end end})
                m = m + 1
                end
                if destroyed then break end
            end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''eval_card(G.jokers.cards[j], {cardarea = G.jokers, remove_playing_cards = true, removed = cards_destroyed})'''
position = "before"
payload = '''
            local retri = 1
            local m = 1
            while m <= retri do
                if m == 1 then
                    if G.jokers.cards[j].ability.retriggers and G.jokers.cards[j].ability.retriggers > 0 then
                        retri = retri + G.jokers.cards[j].ability.retriggers
                    end
                end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''eval_card(G.jokers.cards[j], {cardarea = G.jokers, remove_playing_cards = true, removed = cards_destroyed})'''
position = "after"
payload = '''
            m = m + 1
            end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''play_area_status_text("Not Allowed!")--localize('k_not_allowed_ex'), true)'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''func = (function()  update_hand_text({delay = 0, immediate = true}, {mult = 0, chips = 0, chip_total = math.floor(hand_chips*mult), level = '', handname = ''});play_sound('button', 0.9, 0.6);return true end)'''
position = "before"
payload = '''
]]
        --+++++++++++++++++++++++++++++++++++++++++++++++++++++++++--
        --Joker Debuff Effects
        --+++++++++++++++++++++++++++++++++++++++++++++++++++++++++--
        for i=1, #G.jokers.cards do
            
            --calculate the joker effects
            local retri = 1
            local m = 1
            while m <= retri do
                if m == 1 then
                    if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                        retri = retri + G.jokers.cards[i].ability.retriggers
                    end
                end
            local effects = eval_card(G.jokers.cards[i], {cardarea = G.jokers, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, debuffed_hand = true, callback = function(card, ret) effects = {jokers = ret}

            --Any Joker effects
            if effects.jokers then
                if m ~= 1 then
                    card_eval_status_text(G.jokers.cards[i], 'jokers', nil, nil, nil, {message = localize('s_energy'), colour = G.C.BLACK})
                end
                card_eval_status_text(G.jokers.cards[i], 'jokers', nil, percent, nil, effects.jokers)
                percent = percent+percent_delta
            end
            end})
            m = m + 1
            end
        end 
    end
    G.E_MANAGER:add_event(Event({
        trigger = 'after',delay = 0.4,
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''--calculate the joker after hand played effects'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''if G.GAME.modifiers.debuff_played_cards then'''
position = "before"
payload = '''
]]
        local retri = 1
        local m = 1
        while m <= retri do
            if m == 1 then
                if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                    retri = retri + G.jokers.cards[i].ability.retriggers
                end
            end
        local effects = eval_card(G.jokers.cards[i], {cardarea = G.jokers, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, after = true, callback = function(card, ret) effects = {jokers = ret}
        if effects.jokers then
            if m ~= 1 then
                card_eval_status_text(G.jokers.cards[i], 'jokers', nil, nil, nil, {message = localize('s_energy'), colour = G.C.BLACK})
            end
            card_eval_status_text(G.jokers.cards[i], 'jokers', nil, percent, nil, effects.jokers)
            percent = percent + percent_delta
        end
    end})
    m = m + 1 end end
 
    G.E_MANAGER:add_event(Event({
        trigger = 'immediate',
        func = (function()     
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''G.RESET_JIGGLES = true'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''if G.GAME.round_resets.ante == G.GAME.win_ante and G.GAME.blind:get_type() == 'Boss' then'''
position = "before"
payload = '''
]]
            if G.GAME.chips - G.GAME.blind.chips >= 0 then
                game_over = false
            end
            for i = 1, #G.jokers.cards do
                local retri = 1
                local m = 1
                while m <= retri do
                if m == 1 then
                    if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                        retri = retri + G.jokers.cards[i].ability.retriggers
                    end
                end
                local eval = nil
                eval = G.jokers.cards[i]:calculate_joker({end_of_round = true, game_over = game_over, callback = function(card, eval)
                if eval then
                    if eval.saved then
                        game_over = false
                    end
                    if m ~= 1 then
                        card_eval_status_text(G.jokers.cards[i], 'jokers', nil, nil, nil, {message = localize('s_energy'), colour = G.C.BLACK})
                    end
                    card_eval_status_text(card, 'jokers', nil, nil, nil, eval)
                end
                end})
                m = m + 1
                end
                G.jokers.cards[i]:calculate_rental()
                G.jokers.cards[i]:calculate_perishable()
            end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''if G.STATE == G.STATES.ROUND_EVAL then'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''--If dollars'''
position = "before"
payload = '''
]]
                                win_game()
                                G.GAME.won = true
                                return true
                            end
                        end)
                    }))
                end
                for i=1, #G.hand.cards do
                    --Check for hand doubling
                    local reps = {1}
                    local j = 1
                    while j <= #reps do
                        local percent = (i-0.999)/(#G.hand.cards-0.998) + (j-1)*0.1
                        if reps[j] ~= 1 and reps[j].from_retriggers then
                            card_eval_status_text(reps[j].from_retriggers.card, 'jokers', nil, nil, nil, reps[j].from_retriggers)
                        end
                        if reps[j] ~= 1 then card_eval_status_text((reps[j].jokers or reps[j].seals).card, 'jokers', nil, nil, nil, (reps[j].jokers or reps[j].seals)) end
    
                        --calculate the hand effects
                        local effects = {G.hand.cards[i]:get_end_of_round_effect()}
                        for k=1, #G.jokers.cards do
                            --calculate the joker individual card effects
                            local retri = 1
                            local m = 1
                            while m <= retri do
                                if m == 1 then
                                    if G.jokers.cards[k].ability.retriggers and G.jokers.cards[k].ability.retriggers > 0 then
                                        retri = retri + G.jokers.cards[k].ability.retriggers
                                    end
                                end
                            local eval = G.jokers.cards[k]:calculate_joker({cardarea = G.hand, other_card = G.hand.cards[i], individual = true, end_of_round = true, callback = function(card, eval, retrigger)
                            if eval then 
                                table.insert(effects, eval)
effects[#effects].from_retrigger = retrigger
                                if m ~= 1 then
                                    if G.jokers.cards[k].ability.retriggers and G.jokers.cards[k].ability.retriggers > 0 then
                                        effects[#effects].from_retriggers = {message = localize('s_energy'), colour = G.C.BLACK, card = G.jokers.cards[k]}
                                    end
                                end
end end, no_retrigger_anim = true})
                            m = m + 1
                            end
                        end

                        if reps[j] == 1 then 
                            --Check for hand doubling
                            --From Red seal
                            local eval = eval_card(G.hand.cards[i], {end_of_round = true,cardarea = G.hand, repetition = true, repetition_only = true})
                            if next(eval) and (next(effects[1]) or #effects > 1)  then 
                                for h = 1, eval.seals.repetitions do
                                    reps[#reps+1] = eval
                                end
                            end

                            --from Jokers
                            for j=1, #G.jokers.cards do
                                --calculate the joker effects
                                local retri = 1
                                local m = 1
                                while m <= retri do
                                    if m == 1 then
                                        if G.jokers.cards[j].ability.retriggers and G.jokers.cards[j].ability.retriggers > 0 then
                                            retri = retri + G.jokers.cards[j].ability.retriggers
                                        end
                                    end
                                local eval = eval_card(G.jokers.cards[j], {cardarea = G.hand, other_card = G.hand.cards[i], repetition = true, end_of_round = true, card_effects = effects, callback = function(card, ret) eval = {jokers = ret}
                                if next(eval) then 
                                    for h = 1, eval.jokers.repetitions do
                                        if m ~= 1 and h == 1 then
                                            local _eval = shallow_copy(eval)
                                            _eval.from_retriggers = {message = localize('s_energy'), colour = G.C.BLACK, card = G.jokers.cards[j]}
                                            reps[#reps+1] = _eval
                                        else
                                            reps[#reps+1] = eval
                                        end
                                end end end})
                                m = m + 1
                                end
                            end
                        end
        
                        for ii = 1, #effects do
                            --if this effect came from a joker
                            if effects[ii].from_retriggers then
                                card_eval_status_text(effects[ii].from_retriggers.card, 'jokers', nil, nil, nil, effects[ii].from_retriggers)
                            end
                            if effects[ii].card then
                                G.E_MANAGER:add_event(Event({
                                    trigger = 'immediate',
                                    func = (function() effects[ii].card:juice_up(0.7);return true end)
                                }))
                            end

'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''G.GAME.blind:set_blind(G.GAME.round_resets.blind)'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''G.deck:shuffle('nr'..G.GAME.round_resets.ante)'''
position = "before"
payload = '''
]]
            
            for i = 1, #G.jokers.cards do
                local retri = 1
                local m = 1
                while m <= retri do
                    if m == 1 then
                        if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                            retri = retri + G.jokers.cards[i].ability.retriggers
                        end
                    end
                G.jokers.cards[i]:calculate_joker({setting_blind = true, blind = G.GAME.round_resets.blind})
                m = m + 1
                end
            end
            delay(0.4)

            G.E_MANAGER:add_event(Event({
                trigger = 'immediate',
                func = function()
                    G.STATE = G.STATES.DRAW_TO_HAND
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''G.jokers.cards[j]:calculate_joker({pre_discard = true, full_hand = G.hand.highlighted, hook = hook})'''
position = "before"
payload = '''
            local retri = 1
            local m = 1
            while m <= retri do
                if m == 1 then
                    if G.jokers.cards[j].ability.retriggers and G.jokers.cards[j].ability.retriggers > 0 then
                        retri = retri + G.jokers.cards[j].ability.retriggers
                    end
                end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''G.jokers.cards[j]:calculate_joker({pre_discard = true, full_hand = G.hand.highlighted, hook = hook})'''
position = "after"
payload = '''
            m = m + 1
            end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''for i=1, highlighted_count do'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''table.insert(cards, G.hand.highlighted[i])'''
position = "before"
payload = '''
]]
            local removed = false
            local eval = nil
            eval = eval_card(G.hand.highlighted[i], {discard = true, full_hand = G.hand.highlighted})
            if eval and eval.remove then
                removed = true
                card_eval_status_text(G.hand.highlighted[i], 'jokers', nil, 1, nil, eval)
            end
            for j = 1, #G.jokers.cards do
                local retri = 1
                local m = 1
                while m <= retri do
                    if m == 1 then
                        if G.jokers.cards[j].ability.retriggers and G.jokers.cards[j].ability.retriggers > 0 then
                            retri = retri + G.jokers.cards[j].ability.retriggers
                        end
                    end
                local eval = nil
                eval = G.jokers.cards[j]:calculate_joker({discard = true, other_card =  G.hand.highlighted[i], full_hand = G.hand.highlighted, callback = function(card, eval)
                if eval then
                    if m ~= 1 then
                        card_eval_status_text(card, 'jokers', nil, 1, nil, {message = localize('s_energy'), colour = G.C.BLACK})
                    end
                    if eval.remove then removed = true end
                    card_eval_status_text(card, 'jokers', nil, 1, nil, eval)
                end
                end})
                m = m + 1
                end
            end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''if destroyed_cards[1] then'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''G.GAME.round_scores.cards_discarded.amt = G.GAME.round_scores.cards_discarded.amt + #cards'''
position = "before"
payload = '''
]]
            for j=1, #G.jokers.cards do
                local retri = 1
                local m = 1
                while m <= retri do
                    if m == 1 then
                        if G.jokers.cards[j].ability.retriggers and G.jokers.cards[j].ability.retriggers > 0 then
                            retri = retri + G.jokers.cards[j].ability.retriggers
                        end
                    end
                eval_card(G.jokers.cards[j], {cardarea = G.jokers, remove_playing_cards = true, removed = destroyed_cards})
                m = m + 1
                end
            end
        end

'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({open_booster = true, card = self})'''
position = "before"
payload = '''
                local retri = 1
                local m = 1
                while m <= retri do
                    if m == 1 then
                        if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                            retri = retri + G.jokers.cards[i].ability.retriggers
                        end
                    end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({open_booster = true, card = self})'''
position = "after"
payload = '''
                m = m + 1
                end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({buying_card = true, card = self})'''
position = "before"
payload = '''
            local retri = 1
            local m = 1
            while m <= retri do
                if m == 1 then
                    if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                        retri = retri + G.jokers.cards[i].ability.retriggers
                    end
                end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({buying_card = true, card = self})'''
position = "after"
payload = '''
            m = m + 1
            end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({first_hand_drawn = true})'''
position = "before"
payload = '''
                        local retri = 1
                        local m = 1
                        while m <= retri do
                            if m == 1 then
                                if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                                    retri = retri + G.jokers.cards[i].ability.retriggers
                                end
                            end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({first_hand_drawn = true})'''
position = "after"
payload = '''
                        m = m + 1
                        end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({using_consumeable = true, consumeable = card})'''
position = "before"
payload = '''
        local retri = 1
        local m = 1
        while m <= retri do
            if m == 1 then
                if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                    retri = retri + G.jokers.cards[i].ability.retriggers
                end
            end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({using_consumeable = true, consumeable = card})'''
position = "after"
payload = '''
        m = m + 1
        end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({selling_card = true, card = card})'''
position = "before"
payload = '''
        local retri = 1
        local m = 1
        while m <= retri do
            if m == 1 then
                if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                    retri = retri + G.jokers.cards[i].ability.retriggers
                end
            end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({selling_card = true, card = card})'''
position = "after"
payload = '''
        m = m + 1
        end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''elseif e.config.id ~= 'buy_and_use' then'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''--Tallies for unlocks'''
position = "before"
payload = '''
]]
            if c1.ability.consumeable then
              G.consumeables:emplace(c1)
            else
              G.jokers:emplace(c1)
            end
            G.E_MANAGER:add_event(Event({func = function()
            local retri = 1
            local m = 1
            while m <= retri do
            if m == 1 then
                if c1.ability.retriggers and c1.ability.retriggers > 0 then
                    retri = retri + c1.ability.retriggers
                end
            end
            c1:calculate_joker({buying_card = true, card = c1})
            m = m + 1
            end
            return true end}))
          end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({buying_card = true, card = c1})'''
position = "before"
payload = '''
            local retri = 1
            local m = 1
            while m <= retri do
            if m == 1 then
                if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                    retri = retri + G.jokers.cards[i].ability.retriggers
                end
            end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({buying_card = true, card = c1})'''
position = "after"
payload = '''
            m = m + 1
            end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({ending_shop = true})'''
position = "before"
payload = '''
        local retri = 1
        local m = 1
        while m <= retri do
        if m == 1 then
            if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                retri = retri + G.jokers.cards[i].ability.retriggers
            end
        end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({ending_shop = true})'''
position = "after"
payload = '''
        m = m + 1
        end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({reroll_shop = true})'''
position = "before"
payload = '''
              local retri = 1
              local m = 1
              while m <= retri do
              if m == 1 then
                  if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                      retri = retri + G.jokers.cards[i].ability.retriggers
                  end
              end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({reroll_shop = true})'''
position = "after"
payload = '''
              m = m + 1
              end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({skipping_booster = true})'''
position = "before"
payload = '''
      local retri = 1
      local m = 1
      while m <= retri do
          if m == 1 then
              if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                  retri = retri + G.jokers.cards[i].ability.retriggers
              end
          end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({skipping_booster = true})'''
position = "after"
payload = '''
      m = m + 1
      end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({skip_blind = true})'''
position = "before"
payload = '''
            local retri = 1
            local m = 1
            while m <= retri do
                if m == 1 then
                    if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                        retri = retri + G.jokers.cards[i].ability.retriggers
                    end
                end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({skip_blind = true})'''
position = "after"
payload = '''
            m = m + 1
            end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/misc_functions.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({playing_card_added = true, cards = cards})'''
position = "before"
payload = '''
    local retri = 1
    local m = 1
    while m <= retri do
        if m == 1 then
            if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                retri = retri + G.jokers.cards[i].ability.retriggers
            end
        end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/misc_functions.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({playing_card_added = true, cards = cards})'''
position = "after"
payload = '''
    m = m + 1
    end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({remove_playing_cards = true, removed = destroyed_cards})'''
position = "before"
payload = '''
            local retri = 1
            local m = 1
            while m <= retri do
                if m == 1 then
                    if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                        retri = retri + G.jokers.cards[i].ability.retriggers
                    end
                end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''G.jokers.cards[i]:calculate_joker({remove_playing_cards = true, removed = destroyed_cards})'''
position = "after"
payload = '''
            m = m + 1
            end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''dollars = dollars +  G.GAME.current_round.discards_left*(G.GAME.modifiers.money_per_discard)'''
position = "after"
payload = '''
--[[
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''local ret = G.GAME.tags[i]:apply_to_run({type = 'eval'})'''
position = "before"
payload = '''
]]
    end
    for i = 1, #G.jokers.cards do
        local total_ret = 0
        local retri = 1
        local m = 1
        while m <= retri do
            if m == 1 then
                if G.jokers.cards[i].ability.retriggers and G.jokers.cards[i].ability.retriggers > 0 then
                    retri = retri + G.jokers.cards[i].ability.retriggers
                end
            end
            local ret = G.jokers.cards[i]:calculate_dollar_bonus()
            if ret then
                if m ~= 1 then
                    card_eval_status_text(G.jokers.cards[i], 'jokers', nil, nil, nil, {message = localize('s_energy'), colour = G.C.BLACK})
                end
                total_ret = total_ret + ret
            end
            m = m + 1
        end
        if total_ret and total_ret ~= 0 then
            add_round_eval_row({dollars = total_ret, bonus = true, name='joker'..i, pitch = pitch, card = G.jokers.cards[i]})
            pitch = pitch + 0.06
            dollars = dollars + total_ret
        end
    end
    for i = 1, #G.GAME.tags do
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''self:calculate_joker{selling_self = true}'''
position = "before"
payload = '''
    local retri = 1
    local m = 1
    while m <= retri do
        if m == 1 then
            if self.ability.retriggers and self.ability.retriggers > 0 then
                retri = retri + self.ability.retriggers
            end
        end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''self:calculate_joker{selling_self = true}'''
position = "after"
payload = '''
    m = m + 1
    end
'''
match_indent = false
overwrite = false
